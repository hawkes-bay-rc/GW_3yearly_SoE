dates.posix = as.POSIXlt(dates)
# Year offset
offset = ifelse(dates.posix$mon >= start_month - 1, 1, 0)
# Water year
adj.year = dates.posix$year + 1899 + offset
# Return the water year
adj.year
}
######################### Monthly groundwater level conditions #############################
data_monthly_con <- data_set_com3 %>%
dplyr::group_by(well) %>%
dplyr::mutate(
max_date = max(my_month, na.rm = TRUE),
min_date = min(my_month, na.rm = TRUE),
cur_date = Sys.Date(),
mon_dur = round(difftime(max_date, min_date, units = "weeks") / 52.25),
watyr = wtr_yr(my_month),
seayr = sea_yr(my_month),
) %>%
dplyr::ungroup() %>%
dplyr::group_by(well, month) %>%
dplyr::mutate(
count = dplyr::n(),
rank = rank(av_gl, na.last = TRUE),
con = dplyr::case_when(
av_gl == max(av_gl, na.rm = TRUE) ~ "Highest-ever",
av_gl == min(av_gl, na.rm = TRUE) ~ "Lowest-ever",
av_gl > quantile(av_gl, 0.25, na.rm = TRUE, type = 5) &
av_gl < quantile(av_gl, 0.75, na.rm = TRUE, type = 5) ~ "Normal",
av_gl >= quantile(av_gl, 0.75, na.rm = TRUE, type = 5) &
av_gl < max(av_gl, na.rm = TRUE) ~ "Above-normal",
av_gl <= quantile(av_gl, 0.25, na.rm = TRUE) &
av_gl > min(av_gl, na.rm = TRUE) ~ "Below-normal",
TRUE ~ "NA"
),
month = factor(month, levels = c("July", "August", "September", "October",
"November", "December", "January", "February",
"March", "April", "May", "June"))
) %>%
dplyr::ungroup() %>%
dplyr::filter(count > 9)  # Must have 10 years or more of data
############################### Seasonal groundwater level conditions ######################
data_season_con <- data_set_com3 %>%
dplyr::group_by(well) %>%
dplyr::mutate(
watyr = wtr_yr(my_month),
seayr = sea_yr(my_month),
) %>%
na.omit() %>%
dplyr::group_by(well, seayr) %>%
dplyr::filter(dplyr::n_distinct(month) == 12) %>%
dplyr::ungroup() %>%
dplyr::mutate(
season = forcats::fct_collapse(
month,
Spring = c("September", "October", "November"),
Summer = c("December", "January", "February"),
Autumn = c("March", "April", "May"),
Winter = c("June", "July", "August")
),
season = forcats::fct_relevel(season, "Winter", "Spring", "Summer", "Autumn")
) %>%
dplyr::ungroup() %>%
dplyr::group_by(well, season, seayr) %>%
dplyr::mutate(sea_gl = mean(av_gl, na.rm = TRUE)) %>%
dplyr::distinct(well, season, watyr, sea_gl, .keep_all = TRUE) %>%
dplyr::ungroup() %>%
dplyr::group_by(well, season) %>%
dplyr::mutate(
count = dplyr::n(),
con = dplyr::case_when(
sea_gl == max(sea_gl, na.rm = TRUE) ~ "Highest-ever",
sea_gl == min(sea_gl, na.rm = TRUE) ~ "Lowest-ever",
sea_gl > quantile(sea_gl, 0.25, na.rm = TRUE) &
sea_gl < quantile(sea_gl, 0.75, na.rm = TRUE) ~ "Normal",
sea_gl >= quantile(sea_gl, 0.75, na.rm = TRUE) &
sea_gl < max(sea_gl, na.rm = TRUE) ~ "Above-normal",
sea_gl <= quantile(sea_gl, 0.25, na.rm = TRUE) &
sea_gl > min(sea_gl, na.rm = TRUE) ~ "Below-normal",
TRUE ~ NA_character_
)
) %>%
dplyr::ungroup() %>%
dplyr::select(well, sea_gl, seayr, season, con) %>%
dplyr::distinct() %>%
dplyr::group_by(well) %>%
dplyr::mutate(season_count = dplyr::n()) %>%
dplyr::filter(season_count > 39) %>%  # Must have more than 10 years of seasonal data (4 seasons per year * 10 years)
dplyr::ungroup()
#duplicates <- data_season_con[duplicated(data_season_con), ]
#Prepare data set for analysis
state <- data_set_com3 %>%
dplyr::mutate(
label = paste(well, month, year),
label1 = paste(well, month),
month = factor(month, levels = c("January", "February", "March", "April", "May", "June",
"July", "August", "September", "October", "November", "December")),
value = GL,
year = as.integer(year)) %>%
dplyr::distinct() %>%  # Remove exact duplicates
na.omit()  # Remove rows with NA values
state$label[duplicated(state$label)] #check for duplicate measurements
#Create a dataset with 80% data coverage over the monitoring period and minimum of 5 years (5 data points)
All_GL <- state %>%
group_by(well) %>%
mutate(
end_date = max(datetime),
start_date = min(datetime)    ,
actual_monitoring = round((n() - 1) / 12, 2),
years_monitored = round(as.numeric((end_date - start_date) / 365.25), 1),
coverage = actual_monitoring / years_monitored,
year = as.numeric(year)
) %>%
filter(coverage >= 0.8, years_monitored >= 5) %>%
mutate(period = "Full")
#################################
# Convert well locations to spatial data and transform to NZTM
WellStor_SF <- WellStor %>%
dplyr::select(well, x, y) %>%
sf::st_as_sf(coords = c("x", "y"), crs = 27200, agr = "constant", remove = FALSE) %>%
sf::st_transform(2193) %>%
dplyr::select(well)
# Perform spatial intersections
WellStor_basins <- WellStor_SF %>%
sf::st_intersection(x=allbasins) %>%
sf::st_drop_geometry() %>%
select(well,NAME)
WellStor_EMA <- WellStor_SF %>%
sf::st_intersection(x=EMA_sf) %>%
sf::st_drop_geometry() %>%
select(well, EMA)
# Merge groundwater level (All_GL) data with basin and EMA information
GL_per <- All_GL %>%
select(well, datetime, GL) %>%
left_join(WellStor_basins, by = "well") %>%
mutate(datetime = as.Date(datetime),
hydro_year = ifelse(format(datetime, "%m") >= 7,
as.numeric(format(datetime, "%Y")),
as.numeric(format(datetime, "%Y")) - 1) %>% as.character()) %>%
group_by(well) %>%
mutate(percentile = percent_rank(GL) * 100) %>%
ungroup()
# Merge groundwater level (All_GL) data with EMA information
GL_per_EMA <- All_GL %>%
select(well, datetime, GL) %>%
left_join(WellStor_EMA, by = "well")
GL_per_1_EMA <- data_monthly_con %>%
select(well, datetime, GL, watyr) %>%
left_join(WellStor_EMA, by = "well")
#########################################################
GL_per_combined <- GL_per %>%
filter(hydro_year >= "2004") %>%
bind_rows(mutate(., hydro_year = "Full Record")) %>%
mutate(hydro_year = factor(hydro_year, levels = c(sort(unique(as.numeric(hydro_year))), "Full Record")))
# Identify the last three hydrological years dynamically
highlight_years <- c(as.character(tail(sort(unique(as.numeric(GL_per_combined$hydro_year))), 3)), "Full Record")
last_years <- sort(unique(as.numeric(GL_per_filtered$hydro_year)), decreasing = TRUE)[1:3]
################## by Seasonal Year ######################################
# Group seasonal conditions by season/watyr and graph for each water year for each Aquifer area
data_season_2019_2023_by_aquifer <- data_season_con %>%
mutate(con = fct_relevel(con, "Highest-ever","Above-normal","Normal","Below-normal", "Lowest-ever", )) %>%
ungroup() %>%
dplyr::filter(seayr %in% c(2019, 2020, 2021, 2022, 2023)) %>%
left_join(WellStor) %>%
sf::st_as_sf(coords = c("x","y"),crs = 27200,agr="constant") %>%
sf::st_transform(2193) %>%
sf::st_intersection(x=allbasins) %>%
sf::st_drop_geometry() %>%
select(well,season,con, NAME,seayr) %>%
group_by(season,NAME,seayr,con) %>%
summarise(n=n()) %>%
mutate(per=round(100*n/sum(n))) %>%
ungroup() %>%
na.omit()
# Create a numeric version of the hydrological year positions (1, 2, 3, ...)
# This numeric value will be used for the x-axis so that the shading can work properly.
GL_per_combined$hydro_year_num <- as.numeric(GL_per_combined$hydro_year)
# Create shading data frame using the numeric positions
shading_df_1 <- data.frame(
hydro_year_label = levels(GL_per_combined$hydro_year),
x = 1:length(levels(GL_per_combined$hydro_year))
)
shading_df_1$shade <- rep(c(TRUE, FALSE), length.out = nrow(shading_df_1))
shading_df_1 <- shading_df_1[shading_df_1$shade, ]
shading_df_1$xmin <- shading_df_1$x - 0.5
shading_df_1$xmax <- shading_df_1$x + 0.5
# Now plot using the numeric x position but re-label the x-axis accordingly.
Boxplot <- ggplot(GL_per_combined, aes(x = hydro_year_num, y = percentile, fill = NAME)) +
# Update the shading rectangle to extend only from y = 0 to 100 (or use -Inf if you prefer)
geom_rect(data = shading_df_1,
aes(xmin = xmin, xmax = xmax),
ymin = 0, ymax = 100,   # Changed ymax to 100 (and optionally ymin to 0)
fill = "grey70", alpha = 0.5, inherit.aes = FALSE) +
# Add boxplots with explicit grouping for each hydrological year and NAME
geom_boxplot(aes(group = interaction(hydro_year, NAME)),
color = "black", outlier.shape = NA) +
scale_fill_brewer(palette = "Paired") +
labs(x = "Hydrological Year", y = "Groundwater Level Percentile (%)") +
scale_x_continuous(breaks = 1:length(levels(GL_per_combined$hydro_year)),
labels = levels(GL_per_combined$hydro_year)) +
theme_classic() +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
legend.position = "bottom") +
guides(fill = guide_legend(title = NULL))
#creates a Map folder
dir.create(file.path(rprojroot::find_rstudio_root_file(), "3_State_analysis", "Box_plots"), recursive = TRUE, showWarnings = FALSE)
# Save the plot inside "Box_plots"
ggsave(
filename = file.path(rprojroot::find_rstudio_root_file(), "3_State_analysis", "Box_plots", "Percentile_boxplot.png"),
plot = Boxplot,
width = 10,
height = 6,
dpi = 300
)
#################### option 2 ##########################################
# Convert hydro_year to numeric before summarisation
GL_per_combined_1 <- GL_per_combined %>%
mutate(hydro_year = as.numeric(as.character(hydro_year)))
# Summarise data to get percentiles for ribbon plot
summary_data <- GL_per_combined_1 %>%
filter(NAME == "Heretaunga Plains") %>%
group_by(hydro_year) %>%
summarise(
p10 = quantile(percentile, 0.10, na.rm = TRUE),
p25 = quantile(percentile, 0.25, na.rm = TRUE),
p50 = quantile(percentile, 0.50, na.rm = TRUE),  # Median
p75 = quantile(percentile, 0.75, na.rm = TRUE),
p90 = quantile(percentile, 0.90, na.rm = TRUE)
)
# Option 2 - Create the ribbon plot
Envelope <- ggplot(summary_data, aes(x = hydro_year + 1)) +  # Shift x-axis forward by 1 year
geom_ribbon(aes(ymin = p25, ymax = p75, fill = "25th-75th Percentile"), alpha = 0.5) +
geom_ribbon(aes(ymin = p10, ymax = p90, fill = "10th-90th Percentile"), alpha = 0.3) +
geom_line(aes(y = p50, colour = "Median"), linewidth = 1.2) +
scale_fill_manual(values = c("25th-75th Percentile" = "#66c2a5", "10th-90th Percentile" = "#8da0cb")) +
scale_colour_manual(values = c("Median" = "black")) +
labs(
x = "Hydrological Year",
y = "Groundwater Level Percentile (%)",
fill = "Percentile Ranges",
colour = NULL
) +
theme_classic() +
theme(
axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
legend.position = "bottom"
) +
scale_x_continuous(
breaks = summary_data$hydro_year + 1,  # Adjust breaks for new x-axis
labels = function(x) paste0(x - 1, "-", x)  # Correct "YYYY-YYYY" formatting
)
#creates a Map folder
dir.create(file.path(rprojroot::find_rstudio_root_file(), "3_State_analysis", "Envelope_plot1"), recursive = TRUE, showWarnings = FALSE)
# Save the plot inside "Envelope_plot1"
ggsave(
filename = file.path(rprojroot::find_rstudio_root_file(), "3_State_analysis", "Envelope_plot1", "Percentile_envelope.png"),
plot = Envelope,
width = 10,
height = 6,
dpi = 300
)
#Obtain data for plotting
Envelope_data <- data_set_com3 %>%
group_by(well, month) %>%
mutate(minGL= min(GL, na.rm = TRUE),
maxGL = max(GL, na.rm = TRUE),
Q20 = quantile(GL,0.2, na.rm=TRUE),
Q80 = quantile(GL,0.8, na.rm=TRUE))
######
df <- Envelope_data
plot_per_well <- function(well_ids) {
df_well <- df %>%
dplyr::filter(well == well_ids) # Filter for the current well
g <- ggplot(df_well, aes(x = my_month, y = GL)) +
geom_ribbon(aes(ymin = minGL, ymax = maxGL, fill = "Above/Below\nnormal range"), alpha = 0.5) +
geom_ribbon(aes(ymin = Q20, ymax = Q80, fill = "Normal range\n(20-80th percentile)"), alpha = 1) +
scale_fill_manual(values = c("dodgerblue4", "lightskyblue")) +
geom_line(aes(x = my_month, y = GL, lty = "Groundwater\nLevel"), color = "black", size = 0.5) +
scale_linetype_manual(values = c("dashed")) +
labs(x = "Year",
y = "Groundwater levels (m)",
fill = " ") +
theme(legend.position = "bottom",
legend.direction = "horizontal",
legend.title = element_blank()) +
facet_wrap(~well, scales = "free")
#ggtitle(well_ids)  # Uncomment if you want a title per plot
# Set the target directory for plots
plots_dir <- file.path(rprojroot::find_rstudio_root_file(),
"3_State_analysis",
"Envelope_plots2")
# Check if the directory exists; if not, create it
if (!dir.exists(plots_dir)) {
dir.create(plots_dir, recursive = TRUE)
}
# Save the plot
cowplot::save_plot(file.path(plots_dir, paste0(well_ids, ".png")), g)
# Print progress message
print(paste0("Generating plot for well ", well_ids))
return(g)  # Return the plot (optional)
}
# Get unique well IDs
well_ids <- unique(df$well)
no_well <- length(well_ids)
# Loop through wells and generate plots
for(www in 1:no_well) {
plot_per_well(well_ids[www])
}
#################################################################
# Group monthly conditions by season and graph for each watyr year for each aquifer
ggplot(data_season_2019_2023_by_aquifer, aes(fill=con, y=per, x=season)) +
geom_bar(position="fill", stat="identity")+
scale_fill_manual(values = c("Above-normal"='cyan',
"Below-normal"='yellow',
"Highest-ever"='blue',
"Lowest-ever"='red',
"Normal"='green'))+
theme(axis.text.x = element_text(angle = 45, vjust = 0.15))+
ylab("Percentage")+
ggtitle("Monthly Groundwater level conditions grouped by Season and Year")+
facet_grid(seayr~NAME,scales ="free_x")
ggplot(data_season_2019_2023_by_aquifer, aes(fill=con, y=per, x=season)) +
geom_bar(position="fill", stat="identity")+
scale_fill_manual(values = c("Above-normal"='cyan',
"Below-normal"='yellow',
"Highest-ever"='blue',
"Lowest-ever"='red',
"Normal"='green'))+
theme(axis.text.x = element_text(angle = 45, vjust = 0.15))+
ylab("Percentage")+
ggtitle("Monthly Groundwater level conditions grouped by Season and Year")+
facet_grid(seayr~NAME,scales ="free_x")
#creates a Map folder
dir.create(file.path(rprojroot::find_rstudio_root_file(), "3_State_analysis", "Summary_plots"), recursive = TRUE, showWarnings = FALSE)
# Group monthly conditions by season and graph for each watyr year for each aquifer
Summary_plot <- ggplot(data_season_2019_2023_by_aquifer, aes(fill=con, y=per, x=season)) +
geom_bar(position="fill", stat="identity")+
scale_fill_manual(values = c("Above-normal"='cyan',
"Below-normal"='yellow',
"Highest-ever"='blue',
"Lowest-ever"='red',
"Normal"='green'))+
theme(axis.text.x = element_text(angle = 45, vjust = 0.15))+
ylab("Percentage")+
ggtitle("Monthly Groundwater level conditions grouped by Season and Year")+
facet_grid(seayr~NAME,scales ="free_x")
#creates a Map folder
dir.create(file.path(rprojroot::find_rstudio_root_file(), "3_State_analysis", "Summary_plots"), recursive = TRUE, showWarnings = FALSE)
#Saves the pie chart plot to the created folder as a PNG file
ggsave(filename = file.path(rprojroot::find_rstudio_root_file(), "3_State_analysis", "Summary_plots", "Summary_plot.png"),
plot = Summary_plot,
width = 10, height = 8, dpi = 300)
#By season - note the seasons are different to the watyr by 1 month
#
map_sf_2021_2023_sea <- data_season_con %>%
ungroup() %>%
dplyr::filter(seayr %in% c(2021, 2022, 2023)) %>%
na.omit() %>%
mutate(con = fct_relevel(con, "Highest-ever","Above-normal","Normal","Below-normal", "Lowest-ever", )) %>%
left_join(WellStor) %>%
sf::st_as_sf(coords = c("x","y"),crs = 27200,agr="constant") %>%
sf::st_transform(2193) %>%
sf::st_intersection(x=allbasins) %>%
dplyr::select(NAME, well, season,seayr,sea_gl,con) %>%
dplyr::mutate(year_year = paste(seayr, sep = ' / ')) %>%
dplyr::filter(NAME %in% c("Heretaunga Plains", "Ruataniwha Plains"))
#
#Map
tmap::tmap_mode("plot")
#Here we define the background map for Hawke's Bay
Map_2021_2023_sea_facet_Rua <- tmap::tm_shape(RP_plains_sf)+
tmap::tm_fill()+
tmap::tm_shape(map_sf_2021_2023_sea)+
tmap::tm_dots(col = "con",
palette=c("Above-normal"='deepskyblue',
"Below-normal"='yellow',
"Highest-ever"='blue',
"Lowest-ever"='red',
"Normal"='chartreuse4'),
#title=unique(allData_sf2$month),
title= " ",
stretch.palette = FALSE,
size = 1,
shape =21,
clustering = FALSE,
legend.show = T,
legend.is.portrait = F)+
tmap::tm_facets(c("year_year","season"),free.coords = FALSE)+
tmap::tm_layout(legend.outside = T,
legend.outside.position = "bottom",
legend.position = c(0.1,0.4),
legend.outside.size = 0.15,
legend.text.size = 2)
#creates a Map folder
dir.create(file.path(rprojroot::find_rstudio_root_file(), "3_State_analysis", "Maps"), recursive = TRUE, showWarnings = FALSE)
#saves file
tmap::tmap_save(Map_2021_2023_sea_facet_Rua,
file.path(rprojroot::find_rstudio_root_file(), "3_State_analysis", "Maps", "Map_2021_2023_sea_facet_Rua.png")
)
# HERETAUNGA PLAINS
Map_2021_2023_sea_facet_Here <- tmap::tm_shape(HP_plains_sf)+
tmap::tm_fill()+
tmap::tm_shape(map_sf_2021_2023_sea)+
tmap::tm_dots(col = "con",
palette=c("Above-normal"='deepskyblue',
"Below-normal"='yellow',
"Highest-ever"='blue',
"Lowest-ever"='red',
"Normal"='chartreuse4'),
#title=unique(allData_sf2$month),
title= " ",
stretch.palette = FALSE,
size = 1,
shape =21,
clustering = FALSE,
legend.show = T,
legend.is.portrait = F)+
tmap::tm_facets(c("year_year","season"),free.coords = FALSE)+
tmap::tm_layout(legend.outside = T,
legend.outside.position = "bottom",
legend.position = c(0.1,0.4),
legend.outside.size = 0.15,
legend.text.size = 2,
outer.margins = 0.01)
#
tmap::tmap_save(Map_2021_2023_sea_facet_Here,
file.path(rprojroot::find_rstudio_root_file(), "3_State_analysis", "Maps", "Map_2021_2023_sea_facet_Here.png")
)
# 1. Create a seasonal column from your datetime column and store in GL_per_1
GL_per_1 <- GL_per %>%
mutate(month = month(datetime),
season = case_when(
month %in% c(12, 1, 2) ~ "Summer",
month %in% c(3, 4, 5) ~ "Autumn",
month %in% c(6, 7, 8) ~ "Winter",
month %in% c(9, 10, 11) ~ "Spring"
),
# Change the factor order to Winter, Spring, Summer, Autumn
season = factor(season, levels = c("Winter", "Spring", "Summer", "Autumn"))
)
# 2. Filter for Heretaunga and calculate average seasonal GL; store in heretaunga_seasonal_1
heretaunga_seasonal_1 <- GL_per_1 %>%
filter(NAME == "Heretaunga Plains") %>%
group_by(well, season, hydro_year) %>%
summarise(avg_GL = mean(GL, na.rm = TRUE), .groups = 'drop')
# 3. Calculate percentiles for each season using historical seasonal averages; store in heretaunga_seasonal_2
heretaunga_seasonal_2 <- heretaunga_seasonal_1 %>%
group_by(well, season) %>%
mutate(percentile = percent_rank(avg_GL) * 100) %>%
ungroup() %>%
mutate(category = case_when(
percentile == 0 ~ "Lowest-ever",
percentile <= 25 ~ "Below-normal",
percentile <= 75 ~ "Normal",
percentile < 100 ~ "Above-normal",
percentile == 100 ~ "Highest-ever",
TRUE ~ "Unknown"
))
# 4. Summarise the counts of each category for plotting; store in plot_data_seasonal_1
plot_data_seasonal_1 <- heretaunga_seasonal_2 %>%
group_by(hydro_year, season, category) %>%
summarise(count = n(), .groups = 'drop') %>%
complete(hydro_year, season, category = c("Highest-ever", "Above-normal", "Normal", "Below-normal", "Lowest-ever"),
fill = list(count = 0)) %>%
mutate(category = factor(category, levels = c("Highest-ever", "Above-normal", "Normal", "Below-normal", "Lowest-ever"))) %>%
group_by(hydro_year, season) %>%
mutate(percentage = count / sum(count)) %>%
ungroup() %>%
filter(hydro_year %in% c(2021, 2022, 2023))
# 5. Generate pie charts by season and hydrological year with hydrological years on the left (rows) and seasons on the top (columns)
Pie_by_seasons_HP <- ggplot(plot_data_seasonal_1, aes(x = "", fill = category, y = count)) +
geom_bar(position = "fill", stat = "identity", width = 1, colour = "white") +
geom_text(aes(label = ifelse(percentage == 0, "", paste0(round(percentage * 100, 1), "%"))),
position = position_fill(vjust = 0.5),
size = 3.5,
check_overlap = FALSE) +
coord_polar(theta = "y") +
facet_grid(hydro_year ~ season) +
theme_void() +
scale_fill_manual(name = NULL, values = c(
"Highest-ever" = "dodgerblue",
"Above-normal" = "skyblue",
"Normal" = "forestgreen",
"Below-normal" = "yellow",
"Lowest-ever" = "red"
)) +
theme(strip.text.x = element_text(size = 14),
strip.text.y = element_text(size = 14))
#creates a Map folder
dir.create(file.path(rprojroot::find_rstudio_root_file(), "3_State_analysis", "Pie_plots"), recursive = TRUE, showWarnings = FALSE)
#Saves the pie chart plot to the created folder as a PNG file
ggsave(filename = file.path(rprojroot::find_rstudio_root_file(), "3_State_analysis", "Pie_plots", "Pie_by_seasons_HP.png"),
plot = Pie_by_seasons_HP,
width = 10, height = 8, dpi = 300)
plot_data %>%
filter(NAME != "Minor aquifers") %>%
group_by(NAME, hydro_year) %>%
mutate(percentage = count / sum(count)) %>%
ungroup() %>%
ggplot(aes(x = "", fill = category, y = count)) +
geom_bar(position = "fill", stat = "identity", width = 1, colour = "white") +
geom_text(aes(label = ifelse(percentage == 0, "", paste0(round(percentage * 100, 1), "%"))),
position = position_fill(vjust = 0.5),
check_overlap = TRUE) +
coord_polar(theta = "y") +
facet_wrap(~ NAME + hydro_year) +
theme_void() +
scale_fill_manual(values = c(
"Highest-ever" = "darkblue",
"Above-normal" = "lightblue",
"Normal" = "green",
"Below-normal" = "yellow",
