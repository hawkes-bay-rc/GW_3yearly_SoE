# knitr::opts_chunk$set(echo = TRUE)
# knitr::opts_knit$set(root.dir = "M:/E_Science/Projects/330 GW Quantity/330 SOE reporting/SOE 5 yearly technical report/2020-2023/R_script")
library(RODBC)
library(sf)
library(dplyr)
library(EnvStats)
library(purrr)
library(tidyr)
library(ggplot2)
library(cowplot)
library(rprojroot)
# library(lubridate)
# library(tidyverse)
# library(here)
# library(kableExtra)
# library(reactable)
# library(readr)
# library(grid)
# Set the target directory
# Set the directory where the file is saved
# As of 16/09/2024 this works
target_dir <- file.path(rprojroot::find_rstudio_root_file(), "2_Data_error_checking_and_cleaning")
state_dir <- file.path(rprojroot::find_rstudio_root_file(), "4_Trend_analysis")
# Define the pattern to match the files with the desired prefix
pattern <- "^\\d{4}-\\d{2}-\\d{2}_data_set_com3\\.RData$"
# List files in the directory that match the pattern
files <- list.files(path = target_dir, pattern = pattern, full.names = TRUE)
# Check if there are matching files
if (length(files) > 0) {
# Load the most recent file (if there are multiple, pick the first one)
load(files[1])
message("Loaded file: ", files[1])
} else {
stop("No matching files found.")
}
# Set the target directory
# Set the directory where the file is saved
# As of 16/09/2024 this works
target_dir <- file.path(rprojroot::find_rstudio_root_file(), "2_Data_error_checking_and_cleaning")
state_dir <- file.path(rprojroot::find_rstudio_root_file(), "4_Trend_analysis")
# Define the pattern to match the files with the desired prefix
pattern <- "^\\d{4}-\\d{2}-\\d{2}_data_set_com3\\.RData$"
# List files in the directory that match the pattern
files <- list.files(path = target_dir, pattern = pattern, full.names = TRUE)
# Check if there are matching files
if (length(files) > 0) {
# Load the most recent file (if there are multiple, pick the first one)
load(files[1])
message("Loaded file: ", files[1])
} else {
stop("No matching files found.")
}
#In this step we are connecting directly to WellStor to obtain co-ordinates for our wells
# Connect to the WellStor database and retrieve well coordinates
Con <- RODBC::odbcConnect("HBRCData64", uid="", pwd="")
on.exit(RODBC::odbcClose(Con))
WellStor <- RODBC::sqlQuery(Con, "
SELECT WELLBore.BoreNo AS well,
WELLBore.Easting AS x,
WELLBore.Northing AS y,
WELLBore.SOE_WL,
WELLBore.SOE_WQ
FROM HbrcDB.dbo.WELLBore WELLBore",
stringsAsFactors = FALSE) %>%
mutate(well = as.factor(well))
# Function to read and set CRS for shapefiles
read_shapefile <- function(path, crs = 2193) {
st_read(path) %>%
st_set_crs(crs) %>%
st_transform(crs)
}
gis_dir <- file.path(rprojroot::find_rstudio_root_file(),"GIS_layers")
# Read GIS data with updated relative paths
allbasins <- sf::st_read(file.path(gis_dir, "All_basins7.shp"), crs = 2193) %>%
dplyr::select(NAME)
Regional_boundary_sf <- sf::st_read(file.path(gis_dir, "Regional_boundary.shp"))
sf::st_crs(Regional_boundary_sf) = 2193 # for NZTM
Regional_boundary_sf <- sf::st_transform(Regional_boundary_sf, 2193) %>%
sf::st_cast(to="MULTILINESTRING")
Quaternary_aquifers <- sf::st_read(file.path(gis_dir, "Quaternary_deposits.shp"), crs = 2193)
Pre_qauaternary_aquifers <- sf::st_read(file.path(gis_dir, "Hard_rock_aquifers.shp"), crs = 2193)
# Bounding boxes for the Heretaunga and Ruataniwha Plains
bb_box <- sf::st_read(file.path(gis_dir, "bb_box.shp"), crs = 2193) %>%
sf::st_cast(to="MULTILINESTRING")
SoE_FMUs <- sf::st_read(file.path(gis_dir, "SoE_Areas.shp"), crs = 2193) %>%
dplyr::select(FMU)
HP_plains_sf <- sf::st_read(file.path(gis_dir, "HP_boundary.shp"))
sf::st_crs(HP_plains_sf) = 2193 # EPSG for NZTM 2000
RP_plains_sf <- sf::st_read(file.path(gis_dir, "RuaPlains_boundary.shp"))
sf::st_crs(RP_plains_sf) = 2193 # EPSG for NZTM 2000
EMA_sf <- sf::st_read(file.path(gis_dir, "EMA.shp"))
# Remove ODBC connection
rm(Con)
#Prepare data set for analysis
trend <- data_set_com3 %>%
mutate(label = paste(well,month,year)) %>%
mutate(label1 = paste(well,month)) %>%
mutate(month = factor(month, levels = c("January", "February", "March", "April", "May", "June","July", "August", "September", "October", "November", "December"))) %>%
mutate(value = GL) %>%                       # Assuming 'GL' is a column in your dataframe
mutate(year = as.integer(year)) %>%
na.omit() %>%                                      # Removing rows with NA values
group_by(well, year) %>%
mutate(
max_level = max(av_gl, na.rm = TRUE),
min_level = min(av_gl, na.rm = TRUE),
max_min_diff = max_level - min_level) %>%
ungroup()
trend$label[duplicated(trend$label)] #check for duplicate measurements
#Create datasets with 80% data coverage over the monitoring period and minimum of 5 years (5 data points)
All_GL <- trend %>%
group_by(well) %>%
mutate(
end_date = max(datetime),
start_date = min(datetime)    ,
actual_monitoring = round((n() - 1) / 12, 2),
years_monitored = round(as.numeric((end_date - start_date) / 365.25), 1),
coverage = actual_monitoring / years_monitored,
year = as.numeric(year)
) %>%
filter(coverage >= 0.8, years_monitored >= 5) %>%
mutate(period = "Full")
All_GL1 <- trend %>%
group_by(well) %>%
mutate(
end_date = max(datetime),
start_date = min(datetime)    ,
actual_monitoring = round((n() - 1) / 12, 2),
years_monitored = round(as.numeric((end_date - start_date) / 365.25), 1),
coverage = actual_monitoring / years_monitored,
year = as.numeric(year)
) %>%
filter(coverage >= 0.8, years_monitored >= 5) %>%
mutate(period = "Full") %>%
filter(month == "August")
# Ensure the RData_files folder exists inside 4_trend_analysis
dir.create(file.path(rprojroot::find_rstudio_root_file(), "5_trend_analysis", "RData_files"), recursive = TRUE, showWarnings = FALSE)
# Save the data inside the specified folder
save(All_GL, file = file.path(rprojroot::find_rstudio_root_file(), "5_trend_analysis", "RData_files", paste0(Sys.Date(), "_All_GL1.RData")))
# Function to filter, process, create, and save GL data
save_GL_data <- function(start_year, period_length) {
# Compute the end year and create a period label
end_year <- start_year + period_length
period_label <- paste0(start_year, "_", end_year)
GL_data <- All_GL %>%
filter(datetime >= paste0(start_year, "-07-01") & datetime <= paste0(end_year, "-06-30")) %>%
group_by(well) %>%
mutate(
end_date = max(datetime),
start_date = min(datetime),
actualmonitoring = round((n() - 1) / 12, 2),
maxmonitoring = round(as.numeric(difftime(end_date, start_date, units = "days")) / 365, 2),
coverage = actualmonitoring / maxmonitoring
) %>%
filter(coverage >= 0.8 & (ifelse(period_length == 40, maxmonitoring >= 24, maxmonitoring >= (period_length * 0.8)))) %>%
filter(month == "August") %>%
mutate(period = period_label)
# Assign the data frame to the global environment with a name like GL1984_2024
assign(paste0("GL", period_label), GL_data, envir = .GlobalEnv)
# Build the file path
save_dir <- file.path(rprojroot::find_rstudio_root_file(), "5_trend_analysis", "RData_files")
# Create the directory if it doesn't exist
if (!dir.exists(save_dir)) {
dir.create(save_dir, recursive = TRUE)
}
file_name <- paste0(Sys.Date(), "_GL", period_label, ".RData")
file_path <- file.path(save_dir, file_name)
# Save the dataframe to file
save(list = paste0("GL", period_label), file = file_path)
}
# Generate datasets for different period lengths (10, 20, 30, 40 years)
period_lengths <- c(10, 20, 30, 40)
start_years <- seq(1984, 2024 - min(period_lengths), by = 10)  # Ensures periods don't exceed 2024
# Loop through each period length and start year, and call the function where appropriate
for (period in period_lengths) {
for (start in start_years) {
if (start + period <= 2024) {
save_GL_data(start, period)
}
}
}
# Function to run Kendall tests for Seasonal Variation (SV)
# Function to run Kendall tests for Seasonal Variation (SV) using only max_min_diff
run_kendall_SV <- function(data) {
# Remove unused factor levels to ensure only wells with data are retained
data <- droplevels(data)
results <- data %>%
split(.$well) %>%  # Split data by well
map(~ {
# Check that there are at least 3 non-missing observations
if(sum(!is.na(.$max_min_diff)) >= 3) {
test_result <- tryCatch(
kendallTrendTest(.$max_min_diff ~ .$datetime, alternative = "two.sided"),
error = function(e) NULL
)
if(!is.null(test_result)) {
return(data.frame(
tau_maxmin       = test_result$estimate["tau"],
p_value_maxmin   = test_result$p.value,
# Multiply Sen's slope by 365.25 to convert from m/day to m/year (if datetime is a Date)
sen_slope_maxmin = test_result$estimate["slope"] * 365.25,
intercept_maxmin = test_result$estimate["intercept"],
z_stat_maxmin    = test_result$statistic["z"],
ci_lower_maxmin  = test_result$interval$limits[1],
ci_upper_maxmin  = test_result$interval$limits[2],
n                = test_result$sample.size
))
}
}
# Return NA values if there are insufficient data or an error occurs
return(data.frame(
tau_maxmin       = NA,
p_value_maxmin   = NA,
sen_slope_maxmin = NA,
intercept_maxmin = NA,
z_stat_maxmin    = NA,
ci_lower_maxmin  = NA,
ci_upper_maxmin  = NA,
n                = NA
))
}) %>%
map_dfr(~., .id = "well")  # The .id will capture the well name
# Add significance and trend direction columns
results <- results %>%
mutate(
significance_maxmin = ifelse(!is.na(p_value_maxmin) & p_value_maxmin >= 0.05, "non-sig", "sig"),
direction_maxmin = ifelse(!is.na(tau_maxmin) & tau_maxmin > 0, "positive",
ifelse(!is.na(tau_maxmin) & tau_maxmin < 0, "negative", "no trend"))
)
return(results)
}
# Run Kendall trend tests for Seasonal Variation (SV) for all periods
MK_all_SV         <- run_kendall_SV(All_GL1)
MK_SV_1984_1994   <- run_kendall_SV(GL1984_1994)
MK_SV_1994_2004   <- run_kendall_SV(GL1994_2004)
MK_SV_2004_2014   <- run_kendall_SV(GL2004_2014)
MK_SV_2014_2024   <- run_kendall_SV(GL2014_2024)
MK_SV_1984_2004   <- run_kendall_SV(GL1984_2004)
MK_SV_1994_2014   <- run_kendall_SV(GL1994_2014)
MK_SV_2004_2024   <- run_kendall_SV(GL2004_2024)
MK_SV_1994_2024   <- run_kendall_SV(GL1994_2024)
MK_SV_1984_2014   <- run_kendall_SV(GL1984_2014)
MK_SV_1984_2024   <- run_kendall_SV(GL1984_2024)
#Combine results
#10year
MK_SV_1984_1994$period="1984_1994"
MK_SV_1994_2004$period="1994_2004"
MK_SV_2004_2014$period="2004_2014"
MK_SV_2014_2024$period="2014_2024"
#20year
MK_SV_1984_2004$period="1984_2004"
MK_SV_1994_2014$period="1994_2014"
MK_SV_2004_2024$period="2004_2024"
#30year
MK_SV_1984_2014$period="1984_2014"
MK_SV_1994_2024$period="1994_2024"
#40year
MK_SV_1984_2024$period="1984_2024"
#full
MK_all_SV$period="Full"
MK_SV_combined <- rbind(
#10yr
MK_SV_1984_1994,
MK_SV_1994_2004,
MK_SV_2004_2014,
MK_SV_2014_2024,
#20yr
MK_SV_1984_2004,
MK_SV_1994_2014,
MK_SV_2004_2024,
#30yr
MK_SV_1984_2014,
MK_SV_1994_2024,
#40yr
MK_SV_1984_2024,
#All
MK_all_SV
) %>%
left_join(WellStor) %>%
sf::st_as_sf(coords = c("x","y"),crs = 27200,agr="constant", remove=FALSE) %>%
sf::st_transform(2193)
selection <- MK_SV_combined %>%
dplyr::select(well, x, y) %>%
distinct() %>% # this part minimises the number of records needed for st_intersection
sf::st_intersection(x=allbasins) %>%
#sf::st_intersection(x=SoE_FMUs) %>%
sf::st_drop_geometry()
MK_SV_combined_1 <- MK_SV_combined %>%
dplyr::left_join(., selection) %>%
sf::st_as_sf(coords = c("Easting", "Northing"), crs = 2193, agr = "constant", remove = FALSE) %>%
# If you need geometry, keep the sf conversion; if not, remove st_drop_geometry() or skip the sf conversion entirely
sf::st_drop_geometry() %>%
dplyr::rename(area = NAME) %>%
mutate(period = factor(period, levels = c(
"Full",
"1984_1994",
"1994_2004",
"2004_2014",
"2014_2024",
"1984_2004",
"1994_2014",
"2004_2024",
"1984_2014",
"1994_2024",
"1984_2024"
))) %>%
mutate(area = factor(area, levels = c("Heretaunga Plains", "Ruataniwha Plains", "Minor aquifers"))) %>%
mutate(sig_1 = case_when(
significance_maxmin == "non-sig" ~ "non-sig",
direction_maxmin == "positive" ~ "positive",
direction_maxmin == "negative" ~ "negative",
TRUE ~ "check"
)) %>%
mutate(sig_1 = factor(sig_1, levels = c("positive", "negative", "non-sig", "check")))
# Create the "Tables" directory inside "3_State_analysis" if it doesn't exist
dir.create(file.path(rprojroot::find_rstudio_root_file(), "5_Trend_analysis", "Results_tables"),
recursive = TRUE, showWarnings = FALSE)
# Export the Mann-Kendall results to CSV in the newly created folder
write.table(MK_SV_combined_1,
file = file.path(rprojroot::find_rstudio_root_file(), "5_Trend_analysis", "Results_tables",
paste0(Sys.Date(), "_MK_SV_combined_1.csv")),
sep = ",", row.names = FALSE, quote = FALSE)
# Define folder path and ensure it exists
file_path <- file.path(rprojroot::find_rstudio_root_file(),
"5_Trend_analysis", "Results_shapefiles",
paste0(Sys.Date(), "_MK_SV_combined_sf.shp"))
dir.create(dirname(file_path), recursive = TRUE, showWarnings = FALSE)
#Create and write the shapefile
MK_SV_combined_sf <- MK_SV_combined_1 %>%
left_join(WellStor) %>%
sf::st_as_sf(coords = c("x", "y"), crs = 27200, agr = "constant") %>%
sf::st_transform(2193) %>%
sf::st_write(file_path, delete_layer = TRUE)
# This table counts the number of significant and insignificant trends by well
Trend_summary_by_well_aquifer1 <- MK_SV_combined_1 %>%
group_by(period, area, sig_1) %>%
summarise(n = n_distinct(well), .groups = "drop") %>%
pivot_wider(names_from = period, values_from = n, values_fill = list(n = 0))
#This table counts the number of wells tested for each period
No_unique_wells_tests <- MK_SV_combined_1 %>%
group_by(period, area) %>%
summarise(n = n_distinct(well), .groups = "drop") %>%
pivot_wider(names_from = period, values_from = n, values_fill = list(n = 0))
# This table calculates the average rate of change of significant trends
MK_slope_mean1 <- MK_SV_combined_1 %>%
filter(significance_maxmin == "sig", !is.na(sen_slope_maxmin)) %>%
group_by(period, area) %>%
summarise(n = round(mean(sen_slope_maxmin, na.rm = FALSE), digits = 5), .groups = "drop") %>%
pivot_wider(names_from = period, values_from = n, values_fill = list(n = NA))
# List of areas to process
areas_to_process <- c("Heretaunga Plains", "Ruataniwha Plains", "Minor aquifers")
# Initialise a list to store results
seasonal_area_tables <- list()
for (area_name in areas_to_process) {
# Filter and Process Data for the Current Area
seasonal_area_data <- MK_SV_combined_1 %>%
filter(significance_maxmin == "sig", area == area_name) %>%
group_by(period) %>%  # No 'month' since it's not available
summarise(
mean_annual_slope = round(mean(sen_slope_maxmin, na.rm = TRUE), digits = 2),
.groups = 'drop'
)
# Calculate the Number of Wells Sampled per Period
well_counts <- MK_SV_combined_1 %>%
filter(significance_maxmin == "sig", area == area_name) %>%
group_by(period) %>%
summarise(wells = n_distinct(well))
# Merge the Well Counts Back into the Area Data
seasonal_area_data <- seasonal_area_data %>%
left_join(well_counts, by = "period")
# Store Processed Data
seasonal_area_tables[[area_name]] <- seasonal_area_data
# Print message indicating completion
message("Seasonal Kendall data processed for area: ", area_name)
}
# Define colours for the plot
SoE_colours <- c("#00b189", "#008ca5", "#f15d49", "#92a134", "#00a651", "#00b1b1", "#eebd1c")
# This bar plot shows the number of trends detected for each period
MK_SV_summary_plot <- MK_SV_combined_1 %>%
filter(significance_maxmin == "sig", sig_1 != "check") %>%
select(area, sig_1, period) %>%
group_by(area, period, sig_1) %>%
summarise(value = n(), .groups = "drop") %>%
mutate(
# Recode "positive" to "increasing" and "negative" to "decreasing"
sig_1 = recode(sig_1, positive = "increasing", negative = "decreasing"),
# Define the factor levels explicitly so both categories are shown
sig_1 = factor(sig_1, levels = c("increasing", "decreasing")),
period_group = case_when(
period %in% c("1984_1994", "1994_2004", "2004_2014", "2014_2024") ~ "10 Year Period",
period %in% c("1984_2004", "1994_2014", "2004_2024") ~ "20 Year Period",
period %in% c("1984_2014", "1994_2024") ~ "30 Year Period",
period == "1984_2024" ~ "40 Year Period",
period == "Full" ~ "All periods",
TRUE ~ "Other"
)
) %>%
ggplot(aes(x = sig_1, y = value, fill = sig_1)) +
geom_bar(stat = "identity", position = "dodge") +
facet_grid(area ~ period_group + period, scales = "free") +
scale_x_discrete(drop = FALSE) +  # Ensures that both factor levels appear on each plot
scale_fill_manual(values = SoE_colours) +
theme(
legend.position = "bottom",
legend.title = element_blank(),
strip.text = element_text(size = 12),
axis.text.x = element_text(angle = 45, hjust = 1)
) +
labs(
y = "Number of trends detected",
x = "Trend direction",
title = "Number of Statistically Significant Trends Detected by period"
)
# Define the base directory dynamically using the RStudio project root
base_dir <- file.path(rprojroot::find_rstudio_root_file(), "5_Trend_analysis", "Results_Plots", "Summary_Plots")
# Ensure the base directory exists
dir.create(base_dir, recursive = TRUE, showWarnings = FALSE)
# Define file path for saving
file_path <- file.path(base_dir, "MK_SV_summary_plot.png")
# Save the plot
ggsave(file_path, MK_SV_summary_plot, dpi = 300)
# Plot seasonal variation
All_GL1_sf <- All_GL1 %>%
dplyr::filter(year >2020) %>%
dplyr::select(well, year, max_level,min_level,max_min_diff) %>%
dplyr::left_join(WellStor) %>%
sf::st_as_sf(coords = c("x","y"),crs = 27200,agr="constant") %>%
sf::st_transform(2193)
# Calculate natural breaks (Jenks breaks)
breaks <- classInt::classIntervals(All_GL1_sf$max_min_diff, n = 5, style = "jenks")$brks
# Set minimum and maximum bubble sizes
min_size <- 1.8   # Set your desired minimum size
max_size <- 2  # Set your desired maximum size
tmap::tm_shape(allbasins)+
tmap::tm_fill()+
tmap::tm_shape(Quaternary_aquifers,)+
tmap::tm_fill(col = "Aquifer",
palette = "darkseagreen3",
border.col = "white", lwd = 2, alpha = 0.5,
title = "",
labels = "Quaternary sediments")+
tmap::tm_shape(bb_box)+
tmap::tm_lines(col = "black", lwd = 1,lty = "solid")+
tmap::tm_text("Name", size = 0.8, xmod = 3.3, ymod=0.6)+
tmap::tm_shape(All_GL1_sf)+
tmap::tm_bubbles(size = "max_min_diff",
col = "max_min_diff",
breaks = breaks,
palette = "-RdBu",
scale = c(min_size, max_size))+
tmap::tm_facets(by='year',free.coords = TRUE)+
tmap::tm_legend(title.position =c("left", "bottom"),
title.size=5,
scale=1,
legend.text.size = 1.1)+
tmap::tm_layout(legend.outside = T,
legend.outside.position = "bottom",
legend.text.size = 2)
