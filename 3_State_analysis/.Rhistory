}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
library(ggplot2)
library(cowplot)
library(dplyr)
library(here)
# Set the directory where the file is saved
# Set the relative directory (assuming the script runs from the project root)
target_dir <- file.path(rprojroot::find_rstudio_root_file(), "2_Data_error_checking_and_cleaning")
# Define the pattern to match the files with the desired prefix
pattern <- "^\\d{4}-\\d{2}-\\d{2}_data_set_com1\\.RData$"
# List files in the directory that match the pattern# List files in the directory that match the pattern
files <- list.files(path = target_dir, pattern = pattern, full.names = TRUE)
# Check if there are matching files
if (length(files) > 0) {
# Load the most recent file (if there are multiple, pick the first one)
load(files[1])
message("Loaded file: ", files[1])
} else {
stop("No matching files found.")
}
knitr::opts_chunk$set(echo = TRUE)
library(lubridate)
library(Hilltop)
library(dplyr)
library(stringr)
# Step 1: Extract groundwater level data from Hilltop
dfile <- Hilltop::HilltopData("M:/E_Science/IT/Tideda/HilltopArchive/MonitorWells.hts")
knitr::opts_chunk$set(echo = TRUE)
library(lubridate)
library(Hilltop)
library(dplyr)
library(stringr)
# Step 1: Extract groundwater level data from Hilltop
dfile <- Hilltop::HilltopData("M:/E_Science/IT/Tideda/HilltopArchive/MonitorWells.hts")
# list the sites and measurements
measurements1 <- Hilltop::MeasurementList(dfile,"")
No_sites <- dplyr::data_frame(unique(measurements1$Site))
No_datums <- dplyr::data_frame(unique(measurements1$Measurement))
# list the sites and measurements
Measurement_Summary <- measurements1 %>%
dplyr::group_by(Measurement) %>%
dplyr::summarise(Number_of_sites = n()) %>%
dplyr::arrange(desc(Number_of_sites))
measurements1 %>% dplyr::filter(Measurement=="Depth From Measuring Point [Manual Water Level]") %>% base::nrow()
# Filter sites with MSL datums (Manual and Recorder)
# Filter sites with MSL datums (Manual and Recorder)
data_set1 <- measurements1 %>%
dplyr::filter(Measurement %in% c("Elevation Above Sea Level [Manual Water Level]", "Elevation Above Sea Level [Recorder Water Level]"))
data_set1_manual <- data_set1 %>%
dplyr::filter(Measurement == "Elevation Above Sea Level [Manual Water Level]")
data_set1_recorder <- data_set1 %>%
dplyr::filter(Measurement == "Elevation Above Sea Level [Recorder Water Level]")
# Filter non-MSL sites
data_set2 <- measurements1 %>%
dplyr::filter(!Measurement %in% c("Elevation Above Sea Level [Manual Water Level]", "Elevation Above Sea Level [Recorder Water Level]"))
# Sites in data_set2 but not in data_set1
data_set2a <- anti_join(data_set2, data_set1, by = "Site")
# Filter non-MSL sites with measurements relative to Hawke's Bay datum
data_set3 <- data_set2a %>%
dplyr::filter(Measurement %in% c("Hawkes Bay Datum [Manual Water Level]", "Hawkes Bay Datum [Recorder Water Level]"))
data_set3_manual <- data_set3 %>%
dplyr::filter(Measurement == "Hawkes Bay Datum [Manual Water Level]")
data_set3_recorder <- data_set3 %>%
dplyr::filter(Measurement == "Hawkes Bay Datum [Recorder Water Level]")
# Filter remaining non-MSL sites without Hawke's Bay datum
data_set4 <- data_set2a %>%
dplyr::filter(!Measurement %in% c("Hawkes Bay Datum [Manual Water Level]", "Hawkes Bay Datum [Recorder Water Level]"))
# Sites in data_set4 but not in data_set3
data_set4a <- dplyr::anti_join(data_set4, data_set3, by = "Site")
# Filter sites with measurements relative to Measuring Point
data_set5 <- data_set4a %>%
dplyr::filter(Measurement %in% c("Depth From Measuring Point [Manual Water Level]", "Depth From Measuring Point [Recorder Water Level]"))
data_set5_manual <- data_set5 %>%
dplyr::filter(Measurement == "Depth From Measuring Point [Manual Water Level]")
data_set5_recorder <- data_set5 %>%
dplyr::filter(Measurement == "Depth From Measuring Point [Recorder Water Level]")
# Filter remaining sites without Measuring Point datum
data_set6 <- data_set4a %>%
dplyr::filter(!Measurement %in% c("Depth From Measuring Point [Manual Water Level]", "Depth From Measuring Point [Recorder Water Level]"))
# Sites in data_set6 but not in data_set5
data_set6a <- anti_join(data_set6, data_set5, by = "Site")
# Filter sites with measurements relative to Puddle
data_set7 <- data_set6a %>%
dplyr::filter(Measurement %in% c("Elevation Above Sea Level [Puddle Manual Water Level]", "Elevation Above Sea Level [Puddle Recorder Water Level]"))
data_set7_manual <- data_set7 %>%
dplyr::filter(Measurement == "Elevation Above Sea Level [Puddle Manual Water Level]")
data_set7_recorder <- data_set7 %>%
dplyr::filter(Measurement == "Elevation Above Sea Level [Puddle Recorder Water Level]")
# Filter remaining sites without Puddle datum
data_set8 <- data_set6a %>%
dplyr::filter(!Measurement %in% c("Elevation Above Sea Level [Puddle Manual Water Level]", "Elevation Above Sea Level [Puddle Recorder Water Level]"))
# Sites in data_set8 but not in data_set7
data_set8a <- dplyr::anti_join(data_set8, data_set7, by = "Site")
# Filter sites with measurements relative to Puddle1
data_set9 <- data_set8a %>%
dplyr::filter(Measurement %in% c("Depth From Measuring Point [Puddle Manual Water Level]", "Depth From Measuring Point [Puddle Recorder Water Level]"))
data_set9_manual <- data_set9 %>%
dplyr::filter(Measurement == "Depth From Measuring Point [Puddle Manual Water Level]")
data_set9_recorder <- data_set9 %>%
dplyr::filter(Measurement == "Depth From Measuring Point [Puddle Recorder Water Level]")
# Filter remaining sites without Puddle1 datum
data_set10 <- data_set8a %>%
dplyr::filter(!Measurement %in% c("Depth From Measuring Point [Puddle Manual Water Level]", "Depth From Measuring Point [Puddle Recorder Water Level]"))
# Sites in data_set10 but not in data_set9
data_set10a <- dplyr::anti_join(data_set10, data_set9, by = "Site")
# Filter sites with measurements relative to Stage [Historic Manual Water Level]
data_set11 <- data_set10a %>%
dplyr::filter(Measurement %in% c("Stage [Historic Manual Water Level]", "Stage [Historic Auto Water Level]"))
data_set11_manual <- data_set11 %>%
dplyr::filter(Measurement == "Stage [Historic Manual Water Level]")
data_set11_recorder <- data_set11 %>%
dplyr::filter(Measurement == "Stage [Historic Auto Water Level]")
# Filter remaining sites without Stage [Historic Manual Water Level]
data_set12 <- data_set10a %>%
dplyr::filter(!Measurement %in% c("Stage [Historic Manual Water Level]", "Stage [Historic Auto Water Level]"))
# Sites in data_set12 but not in data_set11
data_set12a <- dplyr::anti_join(data_set12, data_set11, by = "Site")
# Merging sites
Merge_sites <- Reduce(function(...) merge(..., all=TRUE), list(data_set1, data_set3, data_set5,data_set7,data_set9,data_set11))
Merge_unique_sites <- data.frame(unique(Merge_sites$Site))
Merge_No_datums <- dplyr::data_frame(unique(Merge_sites$Measurement))
Merge_Summary <- Merge_sites %>%
dplyr::group_by(Measurement) %>%
dplyr::summarise(Number_of_sites = n())
retrieve_data <- function(data_set, dfile) {
data_result <- NULL
length <- length(data_set$Site)
for(sm in 1:length) {
tempdata <- NULL
zoodata <- NULL
site <- data_set$Site[sm]
meas <- data_set$Measurement[sm]
zoodata <- tryCatch({
GetData(dfile, site, meas, "", "", method="", interval="")
}, error = function(err) {
message(paste(site, meas, err))
})
if(!is.null(zoodata)) {
tempdata <- fortify.zoo(zoodata)
tempdata$Site <- site
tempdata$Measurement <- meas
if(is.null(data_result)) {
data_result <- tempdata
} else {
data_result <- dplyr::bind_rows(data_result, tempdata)
}
}
}
return(data_result)
}
# Retrieve data for each data set and add '1' to the end of the names
data_set1_data_man <- retrieve_data(data_set1_manual, dfile)
data_set1_data_rec <- retrieve_data(data_set1_recorder, dfile)
data_set3_data_man <- retrieve_data(data_set3_manual, dfile)
data_set3_data_rec <- retrieve_data(data_set3_recorder, dfile)
data_set5_data_man <- retrieve_data(data_set5_manual, dfile)
data_set5_data_rec <- retrieve_data(data_set5_recorder, dfile)
data_set7_data_man <- retrieve_data(data_set7_manual, dfile)
data_set7_data_rec <- retrieve_data(data_set7_recorder, dfile)
data_set9_data_man <- retrieve_data(data_set9_manual, dfile)
data_set9_data_rec <- retrieve_data(data_set9_recorder, dfile)
data_set11_data_man <- retrieve_data(data_set11_manual, dfile)
data_set11_data_rec <- retrieve_data(data_set11_recorder, dfile)
data_set_com <- dplyr::bind_rows(
data_set1_data_man, data_set1_data_rec,
data_set3_data_man, data_set3_data_rec,
data_set5_data_man, data_set5_data_rec,
data_set7_data_man, data_set7_data_rec,
data_set9_data_man, data_set9_data_rec,
data_set11_data_man, data_set11_data_rec
) %>%
na.omit(data_set_com)
#test <- unique(data_set_com$Site)
#Here we  calculate the average monthly groundwater level for each site.  This is achieved by combining both manual and recorder measurements which significantly reduces the size of the dataset.
data_set_com1 <- data_set_com %>%
dplyr::filter(str_detect(Site,"Well\\.+[0-9]+")) %>% # Use this to remove sites without well numbers
dplyr::mutate(my_month=lubridate::floor_date(Index,"month")) %>%
dplyr::group_by(Site,my_month) %>%
dplyr::summarise(av_gl=mean(zoodata)) %>%
dplyr::mutate(well=Site) %>%  #here we create a new column for well number
dplyr::mutate(well=stringr::str_extract(Site,"Well\\.+[0-9]+")) %>%
dplyr::mutate(well=sub("Well\\.+","",well)) %>%
dplyr::mutate(well=as.integer(well)) %>%
dplyr::mutate(month=format(my_month,"%B"),year=format(my_month,"%Y"))
#Add date to file
save(data_set_com1, file = paste0("2_Data_error_checking_and_cleaning/", Sys.Date(), "_data_set_com1.RData"))
#Add date to file
dir.create("2_Data_error_checking_and_cleaning", recursive = TRUE, showWarnings = FALSE)
save(data_set_com1, file = paste0("2_Data_error_checking_and_cleaning/", Sys.Date(), "_data_set_com1.RData"))
#Add date to file
dir.create("2_Data_error_checking_and_cleaning", recursive = TRUE, showWarnings = FALSE)
save(data_set_com1, file = paste0("2_Data_error_checking_and_cleaning/", Sys.Date(), "_data_set_com1.RData"))
#Add date to file
# Find the root directory of your RStudio project
root <- rprojroot::find_rstudio_root_file()
# Create a subdirectory path for saving the file
save_dir <- file.path(root, "2_Data_error_checking_and_cleaning")
dir.create(save_dir, recursive = TRUE, showWarnings = FALSE)
# Save the data file using the dynamically created path
save(data_set_com1, file = file.path(save_dir, paste0(Sys.Date(), "_data_set_com1.RData")))
#Add date to file
save_dir <- file.path(rprojroot::find_rstudio_root_file(), "2_Data_error_checking_and_cleaning")
dir.create(save_dir, recursive = TRUE, showWarnings = FALSE)
save(data_set_com1, file = file.path(save_dir, paste0(Sys.Date(), "_data_set_com1.RData")))
#Add date to file
save_dir <- file.path(rprojroot::find_rstudio_root_file(), "2_Data_error_checking_and_cleaning")
dir.create(save_dir, recursive = TRUE, showWarnings = FALSE)
save(data_set_com1, file = file.path(save_dir, paste0(Sys.Date(), "_data_set_com1.RData")))
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
library(dplyr)
library(RODBC)
library(sf)
library(ggplot2)
library(forcats)
library(tidyr)
library(lubridate)
# Set the target directory
# Set the directory where the file is saved
# As of 16/09/2024 this works
target_dir <- file.path(rprojroot::find_rstudio_root_file(), "2_Data_error_checking_and_cleaning")
state_dir <- file.path(rprojroot::find_rstudio_root_file(), "3_State_analysis")
# Define the pattern to match the files with the desired prefix
pattern <- "^\\d{4}-\\d{2}-\\d{2}_data_set_com3\\.RData$"
# List files in the directory that match the pattern
files <- list.files(path = target_dir, pattern = pattern, full.names = TRUE)
# Check if there are matching files
if (length(files) > 0) {
# Load the most recent file (if there are multiple, pick the first one)
load(files[1])
message("Loaded file: ", files[1])
} else {
stop("No matching files found.")
}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
library(dplyr)
library(RODBC)
library(sf)
library(ggplot2)
library(forcats)
library(tidyr)
library(lubridate)
# Set the target directory
# Set the directory where the file is saved
# As of 16/09/2024 this works
target_dir <- file.path(rprojroot::find_rstudio_root_file(), "2_Data_error_checking_and_cleaning")
state_dir <- file.path(rprojroot::find_rstudio_root_file(), "3_State_analysis")
# Define the pattern to match the files with the desired prefix
pattern <- "^\\d{4}-\\d{2}-\\d{2}_data_set_com3\\.RData$"
# List files in the directory that match the pattern
files <- list.files(path = target_dir, pattern = pattern, full.names = TRUE)
# Check if there are matching files
if (length(files) > 0) {
# Load the most recent file (if there are multiple, pick the first one)
load(files[1])
message("Loaded file: ", files[1])
} else {
stop("No matching files found.")
}
# Set the target directory
# Set the directory where the file is saved
# As of 16/09/2024 this works
target_dir <- file.path(rprojroot::find_rstudio_root_file(), "2_Data_error_checking_and_cleaning")
state_dir <- file.path(rprojroot::find_rstudio_root_file(), "4_Trend_analysis")
# Define the pattern to match the files with the desired prefix
pattern <- "^\\d{4}-\\d{2}-\\d{2}_data_set_com3\\.RData$"
# List files in the directory that match the pattern
files <- list.files(path = target_dir, pattern = pattern, full.names = TRUE)
# Check if there are matching files
if (length(files) > 0) {
# Load the most recent file (if there are multiple, pick the first one)
load(files[1])
message("Loaded file: ", files[1])
} else {
stop("No matching files found.")
}
# Set the target directory
# Set the directory where the file is saved
# As of 16/09/2024 this works
target_dir <- file.path(rprojroot::find_rstudio_root_file(), "2_Data_error_checking_and_cleaning")
state_dir <- file.path(rprojroot::find_rstudio_root_file(), "3_State_analysis")
# Define the pattern to match the files with the desired prefix
pattern <- "^\\d{4}-\\d{2}-\\d{2}_data_set_com\\.RData$"
# List files in the directory that match the pattern
files <- list.files(path = target_dir, pattern = pattern, full.names = TRUE)
# Check if there are matching files
if (length(files) > 0) {
# Load the most recent file (if there are multiple, pick the first one)
load(files[1])
message("Loaded file: ", files[1])
} else {
stop("No matching files found.")
}
# Define the GIS layers directory and the shapefile path for WellStor
gis_dir <- file.path(rprojroot::find_rstudio_root_file(), "GIS_layers")
wellstor_shp_path <- file.path(gis_dir, "WellStor.shp")
if (file.exists(wellstor_shp_path)) {
# If the WellStor shapefile exists, load it directly
WellStor_sf <- st_read(wellstor_shp_path)
message("Loaded WellStor from shapefile.")
} else {
# Connect to the WellStor database and retrieve well coordinates
Con <- RODBC::odbcConnect("HBRCData64", uid = "", pwd = "")
on.exit(RODBC::odbcClose(Con))
WellStor <- RODBC::sqlQuery(Con, "
SELECT WELLBore.BoreNo AS well,
WELLBore.Easting AS x,
WELLBore.Northing AS y,
WELLBore.SOE_WL,
WELLBore.SOE_WQ
FROM HbrcDB.dbo.WELLBore WELLBore",
stringsAsFactors = FALSE) %>%
mutate(well = as.factor(well))
# Convert the data frame to an sf object (assuming 'x' and 'y' are in NZTM, EPSG:2193)
WellStor_sf <- st_as_sf(WellStor, coords = c("x", "y"), crs = 2193)
# Save the sf object as a shapefile in the GIS_layers folder
st_write(WellStor_sf, wellstor_shp_path)
message("WellStor shapefile created and saved.")
}
# The remainder of your script continues here...
# For example, reading other GIS layers:
allbasins <- st_read(file.path(gis_dir, "All_basins7.shp"), crs = 2193) %>%
dplyr::select(NAME)
Regional_boundary_sf <- st_read(file.path(gis_dir, "Regional_boundary.shp"))
st_crs(Regional_boundary_sf) <- 2193  # for NZTM
Regional_boundary_sf <- st_transform(Regional_boundary_sf, 2193) %>%
st_cast("MULTILINESTRING")
Quaternary_aquifers <- st_read(file.path(gis_dir, "Quaternary_deposits.shp"), crs = 2193)
Pre_qauaternary_aquifers <- st_read(file.path(gis_dir, "Hard_rock_aquifers.shp"), crs = 2193)
bb_box <- st_read(file.path(gis_dir, "bb_box.shp"), crs = 2193) %>%
st_cast("MULTILINESTRING")
SoE_FMUs <- st_read(file.path(gis_dir, "SoE_Areas.shp"), crs = 2193) %>%
dplyr::select(FMU)
HP_plains_sf <- st_read(file.path(gis_dir, "HP_boundary.shp"))
st_crs(HP_plains_sf) <- 2193  # EPSG for NZTM 2000
RP_plains_sf <- st_read(file.path(gis_dir, "RuaPlains_boundary.shp"))
st_crs(RP_plains_sf) <- 2193  # EPSG for NZTM 2000
EMA_sf <- st_read(file.path(gis_dir, "EMA.shp"))
# Remove ODBC connection
rm(Con)
# Define the GIS layers directory
gis_dir <- file.path(rprojroot::find_rstudio_root_file(), "GIS_layers")
# Create a date stamp in YYYYMMDD format
date_stamp <- format(Sys.Date(), "%Y%m%d")
wellstor_shp_path <- file.path(gis_dir, paste0("WellStor_", date_stamp, ".shp"))
if (file.exists(wellstor_shp_path)) {
# If the WellStor shapefile with today's date exists, load it directly
WellStor_sf <- st_read(wellstor_shp_path)
message("Loaded WellStor from shapefile: ", wellstor_shp_path)
} else {
# Connect to the WellStor database and retrieve well coordinates
Con <- RODBC::odbcConnect("HBRCData64", uid = "", pwd = "")
on.exit(RODBC::odbcClose(Con))
WellStor <- RODBC::sqlQuery(Con, "
SELECT WELLBore.BoreNo AS well,
WELLBore.Easting AS x,
WELLBore.Northing AS y,
WELLBore.SOE_WL,
WELLBore.SOE_WQ
FROM HbrcDB.dbo.WELLBore WELLBore",
stringsAsFactors = FALSE) %>%
mutate(well = as.factor(well))
# Convert the data frame to an sf object (assuming 'x' and 'y' are in NZTM, EPSG:2193)
WellStor_sf <- st_as_sf(WellStor, coords = c("x", "y"), crs = 2193)
# Save the sf object as a shapefile with a date stamp in the file name
st_write(WellStor_sf, wellstor_shp_path)
message("WellStor shapefile created and saved: ", wellstor_shp_path)
}
# Continue with the rest of your GIS layers and processing...
allbasins <- st_read(file.path(gis_dir, "All_basins7.shp"), crs = 2193) %>%
dplyr::select(NAME)
Regional_boundary_sf <- st_read(file.path(gis_dir, "Regional_boundary.shp"))
st_crs(Regional_boundary_sf) <- 2193  # for NZTM
Regional_boundary_sf <- st_transform(Regional_boundary_sf, 2193) %>%
st_cast("MULTILINESTRING")
Quaternary_aquifers <- st_read(file.path(gis_dir, "Quaternary_deposits.shp"), crs = 2193)
Pre_qauaternary_aquifers <- st_read(file.path(gis_dir, "Hard_rock_aquifers.shp"), crs = 2193)
bb_box <- st_read(file.path(gis_dir, "bb_box.shp"), crs = 2193) %>%
st_cast("MULTILINESTRING")
SoE_FMUs <- st_read(file.path(gis_dir, "SoE_Areas.shp"), crs = 2193) %>%
dplyr::select(FMU)
HP_plains_sf <- st_read(file.path(gis_dir, "HP_boundary.shp"))
st_crs(HP_plains_sf) <- 2193  # EPSG for NZTM 2000
RP_plains_sf <- st_read(file.path(gis_dir, "RuaPlains_boundary.shp"))
st_crs(RP_plains_sf) <- 2193  # EPSG for NZTM 2000
EMA_sf <- st_read(file.path(gis_dir, "EMA.shp"))
# Remove ODBC connection
rm(Con)
# Define the GIS layers directory and create a date stamp
gis_dir <- file.path(rprojroot::find_rstudio_root_file(), "GIS_layers")
date_stamp <- format(Sys.Date(), "%Y%m%d")
wellstor_shp_path <- file.path(gis_dir, paste0("WellStor_", date_stamp, ".shp"))
if (file.exists(wellstor_shp_path)) {
# Prompt the user for a decision if the shapefile exists
user_choice <- readline(prompt = paste("File", wellstor_shp_path, "already exists. ",
"Do you want to (L)oad it or (R)etrieve new data? [L/R]: "))
if (tolower(user_choice) == "l") {
# Load the existing shapefile
WellStor_sf <- st_read(wellstor_shp_path)
message("Loaded WellStor from shapefile: ", wellstor_shp_path)
} else if (tolower(user_choice) == "r") {
# Retrieve new data and create a new shapefile
Con <- RODBC::odbcConnect("HBRCData64", uid = "", pwd = "")
on.exit(RODBC::odbcClose(Con))
WellStor <- RODBC::sqlQuery(Con, "
SELECT WELLBore.BoreNo AS well,
WELLBore.Easting AS x,
WELLBore.Northing AS y,
WELLBore.SOE_WL,
WELLBore.SOE_WQ
FROM HbrcDB.dbo.WELLBore WELLBore",
stringsAsFactors = FALSE) %>%
mutate(well = as.factor(well))
WellStor_sf <- st_as_sf(WellStor, coords = c("x", "y"), crs = 2193)
st_write(WellStor_sf, wellstor_shp_path)
message("New WellStor shapefile created and saved: ", wellstor_shp_path)
} else {
message("Invalid input. Defaulting to loading the existing shapefile.")
WellStor_sf <- st_read(wellstor_shp_path)
}
} else {
# If the shapefile doesn't exist, retrieve new data and save it
Con <- RODBC::odbcConnect("HBRCData64", uid = "", pwd = "")
on.exit(RODBC::odbcClose(Con))
WellStor <- RODBC::sqlQuery(Con, "
SELECT WELLBore.BoreNo AS well,
WELLBore.Easting AS x,
WELLBore.Northing AS y,
WELLBore.SOE_WL,
WELLBore.SOE_WQ
FROM HbrcDB.dbo.WELLBore WELLBore",
stringsAsFactors = FALSE) %>%
mutate(well = as.factor(well))
WellStor_sf <- st_as_sf(WellStor, coords = c("x", "y"), crs = 2193)
st_write(WellStor_sf, wellstor_shp_path)
message("WellStor shapefile created and saved: ", wellstor_shp_path)
}
# Continue with the rest of your GIS layers and processing...
allbasins <- st_read(file.path(gis_dir, "All_basins7.shp"), crs = 2193) %>%
dplyr::select(NAME)
Regional_boundary_sf <- st_read(file.path(gis_dir, "Regional_boundary.shp"))
st_crs(Regional_boundary_sf) <- 2193  # for NZTM
Regional_boundary_sf <- st_transform(Regional_boundary_sf, 2193) %>%
st_cast("MULTILINESTRING")
Quaternary_aquifers <- st_read(file.path(gis_dir, "Quaternary_deposits.shp"), crs = 2193)
Pre_qauaternary_aquifers <- st_read(file.path(gis_dir, "Hard_rock_aquifers.shp"), crs = 2193)
bb_box <- st_read(file.path(gis_dir, "bb_box.shp"), crs = 2193) %>%
st_cast("MULTILINESTRING")
SoE_FMUs <- st_read(file.path(gis_dir, "SoE_Areas.shp"), crs = 2193) %>%
dplyr::select(FMU)
HP_plains_sf <- st_read(file.path(gis_dir, "HP_boundary.shp"))
st_crs(HP_plains_sf) <- 2193  # EPSG for NZTM 2000
RP_plains_sf <- st_read(file.path(gis_dir, "RuaPlains_boundary.shp"))
st_crs(RP_plains_sf) <- 2193  # EPSG for NZTM 2000
EMA_sf <- st_read(file.path(gis_dir, "EMA.shp"))
# Remove ODBC connection
rm(Con)
# Increase the console output width to display longer messages
options(width = 150)
# Define the GIS layers directory and create a date stamp
gis_dir <- file.path(rprojroot::find_rstudio_root_file(), "GIS_layers")
date_stamp <- format(Sys.Date(), "%Y%m%d")
wellstor_shp_path <- file.path(gis_dir, paste0("WellStor_", date_stamp, ".shp"))
if (file.exists(wellstor_shp_path)) {
# Prompt the user for a decision if the shapefile exists
user_choice <- readline(prompt = paste("File", wellstor_shp_path, "already exists. ",
"Do you want to (L)oad it or (R)etrieve new data? [L/R]: "))
if (tolower(user_choice) == "l") {
# Load the existing shapefile
WellStor_sf <- st_read(wellstor_shp_path)
cat("Loaded WellStor from shapefile:\n", wellstor_shp_path, "\n")
} else if (tolower(user_choice) == "r") {
# Retrieve new data and create a new shapefile
Con <- RODBC::odbcConnect("HBRCData64", uid = "", pwd = "")
on.exit(RODBC::odbcClose(Con))
WellStor <- RODBC::sqlQuery(Con, "
SELECT WELLBore.BoreNo AS well,
WELLBore.Easting AS x,
WELLBore.Northing AS y,
WELLBore.SOE_WL,
WELLBore.SOE_WQ
FROM HbrcDB.dbo.WELLBore WELLBore",
stringsAsFactors = FALSE) %>%
mutate(well = as.factor(well))
# Convert the data frame to an sf object (assuming 'x' and 'y' are in NZTM, EPSG:2193)
WellStor_sf <- st_as_sf(WellStor, coords = c("x", "y"), crs = 2193)
st_write(WellStor_sf, wellstor_shp_path)
cat("New WellStor shapefile created and saved:\n", wellstor_shp_path, "\n")
} else {
cat("Invalid input. Defaulting to loading the existing shapefile.\n")
WellStor_sf <- st_read(wellstor_shp_path)
}
} else {
# If the shapefile doesn't exist, retrieve new data and save it
Con <- RODBC::odbcConnect("HBRCData64", uid = "", pwd = "")
on.exit(RODBC::odbcClose(Con))
WellStor <- RODBC::sqlQuery(Con, "
SELECT WELLBore.BoreNo AS well,
WELLBore.Easting AS x,
WELLBore.Northing AS y,
WELLBore.SOE_WL,
WELLBore.SOE_WQ
FROM HbrcDB.dbo.WELLBore WELLBore",
stringsAsFactors = FALSE) %>%
mutate(well = as.factor(well))
WellStor_sf <- st_as_sf(WellStor, coords = c("x", "y"), crs = 2193)
st_write(WellStor_sf, wellstor_shp_path)
cat("WellStor shapefile created and saved:\n", wellstor_shp_path, "\n")
}
